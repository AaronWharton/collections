# command-learning


## 操作文件和目录

- **mv** ：mv 命令可以执行文件移动和文件命名任务。任何一种情况下，完成操作后，原来的文件名不再存在。
  
  - 命令：
    ``` powershell
    $ mv item1 item2        # 把文件或目录 item1 移动或重命名为 item2
    $ mv item... directory  # 把一个或多个条目从一个目录移动到另一个目录中
    
    
    # 目录结构如下：
    # +-- watch
    #     +-- watch
    #	      +-- README.md
    #	      +-- .gitignore
    #	      +-- .git
    # 现将子目录 watch 的所有文件移动到根目录 watch 下：
    $ mv watch/* .		# 移动所有非 . 开头的文件
    $ mv watch/.* .		# 移动所有 . 开头的文件
    ```

  - 心得： mv 命令通过移动文件的方式来起到重命名的效果（移动 item1 到 item2。如果 item2 存在，它的内容会被 item1 的内容重写。 如果 item2 不存在，则创建 item2 。每种情况下， item1 不再存在。）。**因此在 linux 系统中，同一个目录下不能出现重名的情况**（例如不能同时在同一个目录下面创建一个名为 test 的文本文件和一个名为 test 的目录）。

- **ln** ： ln 命令既可创建硬链接，也可创建符号链接（软链接）。硬链接可认为是一个文件拥有两个文件名;而软链接则是系统新建一个链接文件，此文件指向其所要指的文件（相当于 windows 中的快捷方式）。软链接实际上只是一段文字，里面包含着它所指向的文件的名字，系统看到软链接后自动跳到对应的文件位置处进行处理；相反，硬联接为文件开设一个新的目录项，硬链接与文件原有的名字是**平权的**，在Linux看来它们是**等价的**。由于这个原因，硬链接不能链接两个不同文件系统上的文件。

  - 命令：
    ``` powershell
    $ ln file1 file2    # 建立硬链接（ file1 只能是文件，不能是目录/文件夹）
    $ ln -s item1 item2 # 建立软链接（ item1 可以是一个文件或者目录/文件夹）
    ```

  - 比较：
      - 软链接可以跨文件系统，硬链接不可以。实践的方法就是用共享文件把 windows 下的 aa.txt 文本文档链接到 linux 下 /root 目录下 bb ，ln -s aa.txt /root/bb 链接成功 。ln aa.txt /root/bb 失败。
      - 关于 I 节点的问题。硬链接不管有多少个，都指向的是同一个I节点。会把结点链接数增加，只要结点的链接数不是0，文件就一直存在，不管你删除的是源文件还是链接的文件。只要有一个存在，文件就存在（其实也不分什么源文件链接文件的 ，因为他们指向都是同一个 I 节点）。当你修改源文件或者链接文件任何一个的时候 ，其他的文件都会做同步的修改。软链接不直接使用i节点号作为文件指针,而是使用文件路径名作为指针。所以删除链接文件对源文件无影响，但是删除源文件，链接文件就会找不到要指向的文件。软链接有自己的inode，并在磁盘上有一小片空间存放路径名。
      - 软链接可以对一个不存在的文件名进行链接。
      - 软链接可以对目录进行链接，而硬链接不能链接目录。


## 使用命令

- 总结起来就是：
  
  - **type** ：显示命令的类型
  - **which** ：显示一个可执行程序所在位置
  - **help** ：得到 shell 内部命令的帮助文档
  - **--help** ：显示用法信息
  - **man** ：显示程序手册页
  - **apropos** ：显示适当（匹配）的程序
  - **whatis** ：显示非常简洁的命令说明
  - **info** ：显示程序 info 目录
  - **alias** ：创建自己的命令（ unalias 删除别名）


## 重定向

- 重定向标准输出：
  
  - 命令：重定向标准输出到另一个文件除了屏幕，我们使用 `>` 重定向符，其后跟着文件名。
      
      ``` powershell
	    $ ls -l /usr/bin > ls.txt   # 将 ls 命令结果重定向到 ls.txt 文本文件中
	    
	    # 如果是向文件追加内容，则使用 >> ：
	    $ ls -l /usr/bin >> ls.txt
	    $ ls -l /usr/bin >> ls.txt
	    $ ls -l /usr/bin >> ls.txt
	    $ ls -l ls.txt              # 此时显示的文件大小是原来的三倍
	    ```

  - 技巧：
    事实上，如果我们需要删除一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：
    ``` powershell
    $ > ls.txt
    ```
    
- 重定向标准错误：

  - 命令：重定向标准错误缺乏专用的重定向操作符。一个程序可以在几个编号的文件流中的任一个上产生输出。我们把这些文件流的前三个看作标准输入、输出和错误， shell 内部参考它们为文件描述符0、1和2。
    ``` powershell
    $ ls -l /bin/usr 2> ls.txt
    ```

- 重定向标准输出和错误到同一个文件：

  - 命令：
    ``` powershell
    $ ls -l /bin/usr > ls.txt 2>&1  # 方式一
    $ ls -l /bin/usr &> ls.txt      # 方式二（ bash 版本）
    ```
    
- 处理不需要的输出：扔掉不想要的命令输出结果（例如错误和状态信息等）。
  
  - 命令：
    ``` powershell
    $ ls -l /bin/usr 2> /dev/null   # /dev/null 是一个系统设备，叫位存储桶，它可以接受输入并不接受任何处理。这里忽略命令执行后的错误信息。
    ```

- **cat** ： cat 命令读取一个或多个文件，然后复制他们到标准输出。
  
  - 命令：
    ``` powershell
    $ cat [file]
    ```
	  当 cat 命令后面不加参数的时候，它从标准输入（通常是键盘）读取数据。由于文件名参数的缺席， cat 复制标准输入到标准输出，我们会看到出现重复的文本行。我们可以用这种行为来`创建简短的文本文件`：
	  ``` powershell
	  $ cat > test.txt
	  This is a test file.    # 使用 Ctrl+D 结束输入
	  $ cat test.txt
	  This is a test file.
	  ```
	    
	- 重定向标准输入：
	  ``` powershell
	  $ cat < test.txt
	  This is a test file.
	  ```
	 

 ## 权限
 
- 总结起来就是：
	- **id** ：显示用户身份号
	- **chmod** ：更改文件模式（读、写、执行）
	- **umask** ：设置默认的文件权限（指文件创建时用户、用户组和其他用户的具有的读写权限，对 umask 的修改只存在于一个 shell 环境中？）
	- **su** ：以另一个用户的身份来运行 shell
	- **sudo** ：以另一个用户的身份来执行命令
	- **chown** ：更改文件所有者
	- **chgrp** ：更改文件组所有权
	- **passwd** ：更改用户密码

- 特别注意的是：
	- `su` 与 `su -` 的区别：
	它们的作用都是切换为 root 用户。如果 su 命令包含 `-l` 选项，则需要为指定用户启动一个需要登录的 shell ，会加载此用户的 shell 环境，并且工作目录会更改到这个用户的 home 目录。如果不指定用户就会假定时 root 用户（通常 `-l` 简写为 `-` ）。区别在于： su 只是切换了 root 身份，但 shell 环境仍然是普通用户的 shell ； 而 su - 连用户和 shell 环境一起切换成 root 身份了。
	
	- `sudo` 与 `su` 的联系：
	两者在功能上相似，不过管理员可以配置 sudo 命令，而且 sudo 命令不需要 root 用户的密码，用户只需要提供自己的密码即可执行命令。
	
	- `chmod` ：
	只有文件的所有者或者 root 用户才能更改文件或目录的模式。该命令支持两种方法改变文件模式：
		
		- 命令：
		  ``` powershell
		  # 使用八进制数字表示法：
		  $ chmod 600 test.txt
		  $ ls -l test.txt
		  -rw------- 1 aaron aaron 0 7月  18 22:35 test.txt
		  
		  # 使用符号表示法：
		  $ ls -l test.txt 
		  -rw-rw-r-- 1 aaron aaron 0 7月  18 22:52 test.txt
		  # u 代表所有者， g 代表所在用户组， o 代表其他用户， a 代表任何人。 + 表示赋予权限， - 表示收回权限， = 表示只让其拥有指明的权限。
		  $ chmod o=x test.txt 
		  $ ls -l test.txt 
		  -rw-rw---x 1 aaron aaron 0 7月  18 22:52 test.txt
		  ```
		
		- 八进制数字表示法：

			| Octal      |     Binary |   File Mode   |
			| :-------- | --------:| :------: |
			|		0	|		000   |	   -–    |
			|		1	|		001   |	  --x    |
			|		2	|		010   |	  -w-   |
			|		3	|		011   |	  -wx  |
			|		4	|		100   |	  r--    |
			|		5	|		101   |	  r-x    |
			|		6	|		110   |	  rw-    |
			|       7  |       111   |    rwx    |


		- 符号表示法：优点是允许你设置文件模式的单个组成部分的属性而不影响其他部分。


## 进程

- 总结起来就是：
	- **ps** ：报告**当前进程快照** --只列出与当前终端会话相关的进程，选项 x 列出所有进程。
	- **top** ：显示**进程详情** -- ps 命令只能查看 ps 命令执行时进程的状态，而 top 命令是动态更新进程状态的。
	- **jobs** ：列出活跃的任务。
	- **bg** ：把一个任务放到后台执行 -- `bg %1` 将 jobs 所列出的1号进程调入后台执行。
	- **fg** ：把一个任务放到前台执行 -- `fg %1` 将 jobs 所列出的1号进程调入前台执行。
	- **kill** ：给一个进程发送信号 -- 不只是杀死进程的作用，有多个选项，必须要有 root 权限才能给不属于你的进程发信号。
	- **killall** ：给多个进程发送信号 -- 不只是杀死进程的作用，有多个选项，必须要有 root 权限才能给不属于你的进程发信号。
	- **shutdown** ：关机或重启系统。

- 拓展延伸：
	- 使用 `Ctrl + Z` 停止一个进程，这样会把一个前台进程放到后台等待。使用 `Ctrl + C` 终止一个进程。
	- 使用 `Ctrl + Z` 停止一个进程后无法使用 kill 杀死该进程，只有当该进程被调入前台才会执行前面的 kill 命令杀死该进程。


## 自定制 shell 提示符

- **export** ： export 命令用来设置或显示环境变量。语法为： `export [-fn] [name[=value] ...] or export -p` 。参数说明：
	- `-f` 　代表[name]中为函数名称。 
	- `-n` 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 
	- `-p` 　列出所有的 shell 赋予程序的环境变量。

- Unix 类系统环境变量中路径名用冒号分隔而不是 Windows/DOS 中的分号。
