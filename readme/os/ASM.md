# ASM
深入理解计算机

## 疑难重点

- 计算机CPU以及大部分编程语言都是从0开始。目的是**寻址方便**。这里我引用一个例子，知乎原文：[为什么有些编程语言的数组要从零开始算？](https://www.zhihu.com/question/24289367/answer/28084673)另外一篇论文说得更仔细 [Why numbering should start at zero?](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html) ，他探讨了两个问题：
	- 为什么区间表示（例如数组范围）总是左闭右开？
	- 为什么总是从零开始？  

	其实这就是一种慢慢形成的习惯。

- 在x86计算机中，数据存储的基本单位是`字节`（byte），**一个字节有8位**。**一个字有2个字节**，还有双字（4字节）、四字（8字节）、八字（16字节）。

- x86处理器采用的是**小端存储/检索格式**，即低位字节存放于变量的起始地址（\*假如双字变量myNum为12345678h，如果将其存放在偏移量为0000的位置，则78h存放在第一个字节0000，56h存放在第二个字节0001……）

- 每一个二进制数字（称为`位`，**bit**）不是0就是1。位自右向左，**从零开始**顺序增量编号。左边的位称为最高有效位（MSB），右边的位称为最低有效位（LSB）。

- 在进行对数的指令操作（例如MOVSX指令进行符号扩展）或者整数扩展前，应该把相应的数制**转换成二进制**。

- 结构自身不占内存空间，但是结构变量会占用内存。结构包含的字段也可以是结构。

- 宏（宏过程）是指被命名的汇编语言语句块，通常在程序开始的时候定义，位于数据段和代码段之前。在调用宏时，预处理程序就把宏代码复制插入到程序内调用发生的位置。宏可以有效地作为过程调用的封装器（wrappers），以简化参数传递和寄存器入栈。

- `宏函数`与`宏过程`有相似的地方，**不同的是：宏函数通过EXITM伪指令总是返回一个常量**（整数或字符串，用`<>`涵盖）。EXITM（退出宏）伪指令终止了所有后续的宏展开。在调用宏函数时，如果有参数，**它的实参列表必须用圆括号括起来**。

- 大型源文件难于管理且汇编速度慢；若把单个文件拆分成多个子文件也要对整体进行汇编。更好的方法是把一个程序按模块（module）划分，每个模块单独汇编，修改时修改相应的模块，再重汇编该模块，然后用链接器将所有汇编好的模块（OBJ文件）组合为一个可执行文件（这个速度是相当快的：链接大量目标模块比汇编同样数量的源代码文件花费的时间要少得多）。新建多模块两种常用的方法：①传统方法是使用EXTERN伪指令；②使用Microsoft的高级伪指令INVOKE和PROTO。

- 链接库、CALL指令与EXTERN/PROTO伪指令：`链接库是一种文件`，包含了已经汇编为机器代码的过程（子程序）。`CALL指令调用一个过程`，指挥处理器从新的内存地址开始执行（\*目前只见于在同一个.asm文件里面进行过程调用）。EXTERN伪指令主要针对将可执行文件分为多个模块时，调用当前模块之外的过程，它确定过程名和堆栈帧大小（`EXTERN sub1@0:PROC`,另写作：`AddTwo PROTO, val1:DWORD, val2:DWORD`,调用过程sub1，`@0`表示已声明参数占用的堆栈空间总量，每个参数占用四字节，假如一个过程需要传入三个参数，则可以写成`@12`）。

- 过程预留返回地址的空间（**4字节**）。-->**有疑问**

- `堆栈帧`是一个为过程预留的堆栈区域，用来存储关于局部变量、传递参数、返回地址和被保存寄存器的信息。堆栈帧通常是在新的过程调用的时候创建，并在过程返回的时候销毁。

- 条件汇编指令使用见P333.注意与P177的运行时伪指令（条件控制流伪指令）区别开来。条件控制流伪指令（P177）前面有一个`.`，条件汇编指令通常用于宏中，使宏更加灵活。

- `TSL`指令:进程间互斥-保证同一时间只有一个进程进入临界区。要实现TSL指令需要硬件支持。指令为：`TSL RX, LOCK`。该指令执行以下动作：
    - 读取Lock的值
    - 把读到的值存入寄存器RX中
    - 给LOCK设置一个非0的值（设置到LOCK对应的内存中）。
    
    以上三个步骤是一个不可拆分的原子操作，执行该指令的CPU将会锁住内存总线（memory bus），所以在该指令执行完成之前其他CPU是无法访问内存的。
    
- `TSL和中断屏蔽的区别`：当一个CPU将中断屏蔽后，只影响当前屏蔽中断的CPU，其他CPU还是依然可以照样访问内存的（想要中断）。唯一一个当一个CPU在访问内存时阻止其他CPU访问内存的方法就是将内存总线锁住，这个需要硬件的支持，TSL可以达到该目的。

- `利用TSL完成进程间互斥`：
    ```
    enter_region：
	    tsl register, lock  ; 复制lock到寄存器，并将lock置为1
	    cmp register, #0    ; lock等于0吗?
	    jne enter_region    ; 如果不等于0，已上锁，再次循环
	    ret                 ; 返回调用程序，进入临界区

	leave_region：
	    move lock, #0   ; 置lock为0
	    ret             ; 返回调用程序
    ```

- 前缀表达式：+ 3 5；后缀表达式：3 5 +；中缀表达式：3 + 5。

- Intel 8086 处理器的设计使之只能进行整数运算，在纯粹地通过软件来模拟浮点运算也会带来严重的性能损失。于是Intel发售一款独立浮点协处理芯片**8087**，当Intel 486 出现时，浮点硬件就被集成到主CPU中，称为FPU。`FPU`使用自己的一组寄存器——寄存器栈（register stack），为8个独立的、可寻址的80位数据寄存器，其中6个专用寄存器（P411）。

- 混合模式运算：整数与浮点数运算，使用CPU和FPU：
	```C++
	int N = 20;
	double X = 3.5;
	int Z = (int) (N + X);
	```
	汇编为：
		
		flid N  ; 整数加载到ST(0)
		fadd X  ; 将内存操作数与ST(0)相加
		fist Z  ; 将ST(0)保存为整型内存操作数
		

    汇编的方式很多种。当浮点型转换为整型时可以使用指令让浮点数进位或者舍弃小数位。
    
- `高级语言接口`（P438）：    
    - 语言使用的`命名规范`
    - 段名称必须与高级语言使用的名称`兼容`
    - 汇编程序使用的`内存模式`（`.model`：微模式、紧凑模式、平坦模式……）决定了段大小以及调用/引用最近/远
    - 内嵌汇编代码： Visual C++ 中的`__asm`伪指令
    - 汇编程序与 `C/C++` 的链接（操作复杂，配置受编译器、处理器等的影响）


## 指令操作

- `add`指令操作：add dest,source，语言表述为：**dest=dest+source**

- `sub`指令操作：sub dest,source，语言表述为：**dest=dest-source**

- `mul/div`指令操作：mul/div reg/mem8/mem16/mem32（不能使用立即数），乘积保存在AX/DX:AX/EDX:EAX。要求在执行MUL后检查进位标志位：确认忽略乘积的高半部分是否安全。详见**P199~P210**

- `RET`指令：当在程序启动过程之外创建一个过程时，需要用RET指令结束它。`RET强制CPU返回到该过程被调用的位置`。

- `MOVZX`指令（进行全零扩展并传送），将源操作数复制到目的操作数，并把目的操作数扩展到16位或32位，这条指令只用于无符号整数；`MOVSX`指令（进行符号扩展并传送）将原始操作数内容复制到目的操作数，并把目的操作数符号扩展到16位或者32位，这条指令只用于有符号整数。目的操作数在进行符号位扩展时，在目的操作数的全部扩展位上重复长度较小操作数（要先转换成二进制）的最高位（0或者1）。
    ```
	; MOVZX指令示例
	mov   bx,0A69Bh
	movzx eax,bx    ; EAX = 0000A69Bh
	movzx edx,bl    ; EDX = 0000009Bh
	movzx cx,bl     ; CX  = 009Bh

	; MOVSX指令示例
	mov   bx,0A69Bh
	movsx eax,bx    ; EAX = FFFFA69Bh
	movsx edx,bl    ; EDX = FFFFFF9Bh
	movsx cx,bl     ; CX  = FF9Bh
	```


## 伪指令操作

- `EQU`伪指令把一个符号名称与一个整数表达式或一个任意文本连接起来：name EQU expression/symbol/\<text\>

- `ALIGN`伪指令会使其后的字段或变量按地址对齐，目的是获得最好的IO性能。`ALIGN BYTE/WORD/DWORD/QWORD...`

- `LABEL`伪指令插入一个符号，并定义它的大小属性，但是不为这个标号分配存储空间。常见的用法是：为数据段中定义的下一个变量提供不同的名称和大小属性（P90）。

- `ENTER`指令为被调用过程自动创建堆栈帧（把EBP入栈->把EBP设置为堆栈帧的基址->为局部变量保留空间），语言表述为：**ENTER numbytes, nestinglevel**,这两个操作数均为立即数，nunbytes总是向上舍入为4的倍数，以便ESP对齐双边字节，nestinglevel确定了从主调过程堆栈帧复制到当前帧的堆栈指针的个数。与之相反，LEAVE指令结束一个过程的堆栈帧，语言表述为：**LEAVE**。

- `LOCAL`伪指令是作为ENTER指令的高级替补，LOCAL声明一个或多个变量名，并定义其大小和属性，*LOCAL必须紧跟PROC伪指令后面*语言表述为：**LOCAL temp:DWORD, sum:BYTE**。

- `INVOKE`伪指令将参数入栈（**按照MODEL伪指令的语言说明符所指定的顺序，仔细看下面的例子INVOKE和push调用参数的顺序**）并调用过程。INVOKE是CALL指令的一个方便的替代品，因为它能用一行代码传递多个参数：**INVOKE procedureName [, argumentList]**。其中ArgumentList就是可选的多个参数集合，参数之间用，分隔。举个栗子：

    ```
    push TYPE array
    push LENGTHOF array
    push OFFSET array
    call DumpArray
    ```
    可以写成：    
    ```
    INVOKE DumpArray, OFFSET array, LENGTHOF array, TYPE array
    ```
    更优美：
	```
	INVOKE DumpArray,   ; 调用DumpArray过程    
	OFFSET array,     ; 数组元素大小类型    
	LENGTHOF array,   ; 数组长度    
	TYPE array        ; 指向数组
	```

    > 覆盖EAX和EDX：若传递的参数小于32位，入栈之前为了扩展参数使汇编器覆盖EAX和EDX的内容。。。避免此情况：   
    ①总是传递32位的参数给INVOKE;    
    ②在过程调用之前保存EAX和EDX,在过程调用之后再回复它们的值（使用栈push和pop）。

- `PROC`是子程序定义伪指令，基本语法：**label PROC [attributes] [USES reglist], parameter_list**，其中parameter_list（每个参数的语法：**parameterName:type**）若为多个则用逗号分隔开，attributes是指下述任一内容：[distance] [langtype] [visibility] [prologuearg]

    | attribute    | instructions  |
    | :-------     | :--:          |
    | distance     | NEAR或FAR。指定汇编器生成的RET指令（RET或RETF）类型 |
    | langtype     | 指定调用规范（参数传递规范），如C、PASCAL或STDCALL。能覆盖由.MODEL伪指令指定的语言 |
    | visibility   | 指明本过程对其他模块的可见性。选项包括PRIVATE、PUBLIC（默认项）和EXPORT。若可见性为EXPORT，则链接器把过程名放入分段可执行文     件的导出表。EXPORT也使之具有了PUBLIC可见性 |
    | prologuearg  | 指定会影响开始和结尾代码生成的参数 |

- `PROTO`伪指令在*64模式*中指定程序的外部过程，在*32位模式中*用处更大：它可以包含过程参数列表，为现有过程创建原型（prototype）。原型声明了过程的名称和参数列表。它还允许在定义过程之前对其进行调用，并验证参数的数量和类型是否与过程的定义相匹配。它与INVOKE、PROC的标准调用顺序为：    
    ```
    MySub PROTO     ; 过程原型（*相当于检查该过程的属性：传值类型，传值数目等）
    ……
    INVOKE MySub    ; 过程调用（*将汇编时常数值送入过程）
    ……
    MySub PROC      ; 过程实现（*用INVOKE送入的值执行该过程）
    ……
    MySub ENDP
    ```
    或者：
    ```
    MySub PROC      ; 过程定义
    ……
    MySub ENDP
    ……
    INVOKE MySub    ; 过程调用
    ```
> PROTO伪指令帮助汇编器比较过程调用和过程定义的参数列表。但是这个错误检查没有如C和C++语言中那样重要。相反，MASM（Microsoft Macro Assembler:微软公司为x86 微处理器家族开发的汇编开发环境，拥有可视化的开发界面，编译速度快，支持80x86汇编以及Win32Asm--百度百科）检查参数正确的数量，并在某些情况下，匹配形式参数和实际参数的类型。

    `MASM会检测到的错误：实际参数超过了形式参数声明的大小+调用过程时添加的参数数目不等于形式参数个数`    
    `MASM不会检测到的错误：实际参数的类型小于形式参数声明的类型大小->并且MASM会把实际参数扩展为形式参数声明的类型大小`


## 运算符

- `ADDR`运算符:用于使用INVOKE调用过程时*传递指针参数*：   
INVOKE FillArray, ADDR myArray/[myArray+4]    ;调用FillArray过程并向其传递myArray的地址       
INVOKE FillArray, ADDR ebp/[ebp+12]           ;错误，传递给ADDR运算符的参数必须是汇编时常数       
**ADDR运算符只能与INVOKE一起用**

- `OFFSET`运算符返回biao'hao数据标号的偏移量（偏移量按字节计算，表示的是该数据标号距离数据段起始地址的距离）。

- `USES`运算符与PROC伪指令一起使用（也就是USES只用于过程而不能用于其他地方，例如`宏`），语言表述为：`xxx PROC USES esi/ecx/...`。USES告诉编译器做两件事：在过程开始时生成push指令&在过程结束后生成pop指令。

- `PTR`运算符：可以用来重写一个已经被声明过的操作数的大小类型；PTR也可与间接操作数一起使用，用以指定结构类型：
	```
	mov ax,WORD PTR myDouble    ; 运用PTR运算符将双字变量myDouble的低16位传送给AX
	(COORD PTR [esi]).X         ; 引用COORD结构中的X字段
	```

- 在宏中常用的运算符：     
	`&`：替换运算符，解析对宏参数名的有歧义的引用。        
	`<>`：文字文本运算符，把一个或多个字符和符号组合成一个文字文本（直接将多个字符放在<>即可）。       
	`!`：构造文字字符运算符，与`<>`的功能几乎完全一样。`!>`可防止`>`被当作文字文本运算符（跟C语言的转义字符相似）。        
	`%`：展开运算符，展开文本宏并将常量表达式转换为文本形式。
	

## 扩展

- `S-表达式`：所谓“S-表达式/运算式”或“sexp”（其中“S”代表“符号的”），是指一种以人类可读的文本形式表达半结构化数据的约定。S-表达式可能以其在Lisp家族的编程语言中的使用而为人所知。语法细节和所支持的数据类型虽因语言而异，但这些语言间最通用的特性则是使用S-表达式作为括号化的__前缀表示法__（有时亦作剑桥波兰表示法）。
