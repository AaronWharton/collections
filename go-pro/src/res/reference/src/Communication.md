# 如何理解 Golang 中“不要通过共享内存来通信，而应该通过通信来共享内存”？

> Do not communicate by sharing memory; instead, share memory by communicateing.


## 为什么需要通信

[进程](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B)（ Process ）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是[操作系统](http://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192)结构的基础。每一个进程都有自己的一部分独立的系统资源，
**彼此是隔离的**。为了使不同的进程互相访问资源并进行协调工作，就有了进程间通信（ IPC ），即这里所说的 `通信` 。


## 共享内存

现在我们知道不同进程彼此是隔离的，所以不同进程间的内存是相互独立的，即两个不同的进程没办法直接互相操作对方的数据。而`共享内存`则是靠操作系统提供的内存映射机制，让不同进程的一块地址空间映射到同一个虚拟内存区域上，这样不同的进程就可以在这块虚拟内存上共用数据。（据说 共享内存是效率最高的进程间通讯机制，因为数据不需要在内核和程序之间复制。 这个待考证）

共享内存调用系统提供的 [mmap](http://man7.org/linux/man-pages/man2/mmap.2.html) 函数。它可以将一个文件映射到虚拟内存的一个区域中，程序使用指针引用这个区域，对这个内存区域的操作会被回写到文件上。 Go 中使用 cgo 调用原生的 `mmap` 。


## 为什么不要通过共享内存来通信

共享内存势必会让多个进程（这里是指 goroutine ）同时访问（write）相同数据，这就会造成数据争用（ [data race](http://wysocki.in/golang-concurrency-data-races/) ）。不过可以使用 `sync.Mutex` 使数据同一时间只能进行单次访问。但是，过多地使用 `sync.Mutex` 会使内存增大（这个也不一定，有时也要看业务逻辑，比如共享对象的大小）、降低代码的可读性以及后期的维护。举个例子：当多个 goroutine 都需要创建同一个对象的时候，如果 goroutine 过多，可能导致对象的创建数目陡增，因为对象要占用内存，然后就导致“并发大 - 占用内存大 - GC 缓慢 - 处理并发能力降低 - 并发更大”恶性循环中（当然这个时候可以使用 `sync.Pool` 来维护对象池）。


## 通过通信来共享内存

**通过通信来共享内存**是通过 channel 之间的通信实现不同进程（ goroutine ）之间的数据共享。前面讲到共享内存可以共用数据， Go 提供了 channel 来实现不同 goroutine 间的通信，所以我们可以维护一个 channel 来作为不同 goroutine 之间沟通的桥梁（这也可以避免 data race ）。


## 选择

*不要通过共享内存来通信，而应该通过通信来共享内存* 只是一种建议，并不意味着使用 `sync.Mutex` 会降低程序性能、代码维护等等一些乱七八糟的问题。更多是一种编程习惯，要选哪一种方式，自己结合实际情况考虑，推荐阅读[Use a sync.Mutex or a channel?](https://github.com/golang/go/wiki/MutexOrChannel)
